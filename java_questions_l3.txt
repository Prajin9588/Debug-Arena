    private static func generateJavaLevel3Questions() -> [Question] {
        var questions: [Question] = []

        questions.append(Question(
            title: "Level 3 – Question 1",
            description: "Why does the object keep its default value even after passing data to the constructor?",
            initialCode: "class User {\n    private String name;\n\n    public User(String name) {\n        name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n}",
            correctCode: "public User(String name) {\n    this.name = name;\n}",
            difficulty: 3,
            riddle: "Two names enter. One stays unchanged.",
            conceptExplanation: "The parameter shadows the instance variable. Use this.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 2",
            description: "Why does the program print 5 even though the object is of type B?",
            initialCode: "class A { int x = 5; }\nclass B extends A { int x = 10; }\n\nA obj = new B();\nSystem.out.println(obj.x);",
            correctCode: "Use a method instead:\n\nclass A { int getX() { return 5; } }\nclass B extends A { int getX() { return 10; } }",
            difficulty: 3,
            riddle: "The object is B.\nThe reference is A.\nWho speaks?",
            conceptExplanation: "Fields are not polymorphic. Methods are.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 3",
            description: "Why does casting cause a runtime error?",
            initialCode: "class Animal {}\nclass Dog extends Animal {}\n\nAnimal a = new Animal();\nDog d = (Dog) a;",
            correctCode: "Animal a = new Dog();\nDog d = (Dog) a;",
            difficulty: 3,
            riddle: "You changed the label.\nBut not the object.",
            conceptExplanation: "Casting does not change the actual object type.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 4",
            description: "Why doesn't the child version execute?",
            initialCode: "class A {\n    void show() {}\n}\n\nclass B extends A {\n    void show(int x) {}\n}",
            correctCode: "@Override\nvoid show() {}",
            difficulty: 3,
            riddle: "Same name. Different shape.",
            conceptExplanation: "Method signature must match exactly.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 5",
            description: "Why does this throw an exception?",
            initialCode: "class Test {\n    String text;\n\n    void print() {\n        System.out.println(text.length());\n    }\n}",
            correctCode: "String text = \"\";\n\n\nOR null check.",
            difficulty: 3,
            riddle: "You asked something from nothing.",
            conceptExplanation: "The variable was never initialized.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 6",
            description: "Why does this fail to compile?",
            initialCode: "class Parent {\n    Parent(int x) {}\n}\n\nclass Child extends Parent {\n    Child() {}\n}",
            correctCode: "Child() {\n    super(10);\n}",
            difficulty: 3,
            riddle: "Before the child lives, the parent must exist.",
            conceptExplanation: "Parent has no default constructor.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 7",
            description: "Why does it print "Parent"?",
            initialCode: "class Parent {\n    static void show() {\n        System.out.println(\"Parent\");\n    }\n}\n\nclass Child extends Parent {\n    static void show() {\n        System.out.println(\"Child\");\n    }\n}\n\nParent obj = new Child();\nobj.show();",
            correctCode: "Use non-static method.",
            difficulty: 3,
            riddle: "Static methods obey the reference, not the object.",
            conceptExplanation: "Static methods are hidden, not overridden.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 8",
            description: "Why do all objects share the same count?",
            initialCode: "class Counter {\n    static int count = 0;\n\n    Counter() {\n        count++;\n    }\n}",
            correctCode: "Remove static if per-object count needed.",
            difficulty: 3,
            riddle: "One variable. Many instances.",
            conceptExplanation: "Static variables belong to the class.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 9",
            description: "Why can't I access child-specific method?",
            initialCode: "interface A {\n    void show();\n}\n\nclass B implements A {\n    public void show() {}\n    void extra() {}\n}\n\nA obj = new B();\nobj.extra();",
            correctCode: "B obj = new B();\nobj.extra();",
            difficulty: 3,
            riddle: "Reference limits visibility.",
            conceptExplanation: "Interface reference exposes only interface methods.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 10",
            description: "Why are logically equal objects stored twice?",
            initialCode: "class User {\n    int id;\n\n    public boolean equals(Object o) {\n        return ((User)o).id == this.id;\n    }\n}",
            correctCode: "@Override\npublic int hashCode() {\n    return Integer.hashCode(id);\n}",
            difficulty: 3,
            riddle: "Equal in comparison.\nDifferent in bucket.",
            conceptExplanation: "Must override both equals and hashCode.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 11",
            description: "Why does adding elements to a method parameter list not affect the original list?",
            initialCode: "void addItem(List<String> items) {\n    items = new ArrayList<>();\n    items.add(\"New\");\n}\n\nList<String> myList = new ArrayList<>();\naddItem(myList);\nSystem.out.println(myList.size());",
            correctCode: "void addItem(List<String> items) {\n    items.add(\"New\");\n}",
            difficulty: 3,
            riddle: "The container was replaced. Original untouched.",
            conceptExplanation: "Assignment rebinds the local reference; it does not affect the caller's object.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 12",
            description: "Why does Thread.stopRequested not stop the thread?",
            initialCode: "class Worker extends Thread {\n    boolean stopRequested = false;\n\n    public void run() {\n        while (!stopRequested) {\n            // do work\n        }\n    }\n}\n\nWorker w = new Worker();\nw.start();\nw.stopRequested = true;",
            correctCode: "volatile boolean stopRequested = false;",
            difficulty: 3,
            riddle: "Changes exist, but the CPU sees the old.",
            conceptExplanation: "Thread visibility issue; must declare the flag volatile.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 13",
            description: "Why does == fail for two objects with the same values?",
            initialCode: "class Point {\n    int x, y;\n    Point(int x, int y) { this.x = x; this.y = y; }\n}\n\nPoint p1 = new Point(1,2);\nPoint p2 = new Point(1,2);\n\nSystem.out.println(p1 == p2);",
            correctCode: "System.out.println(p1.equals(p2));\n\n@Override\npublic boolean equals(Object o) {\n    Point p = (Point) o;\n    return p.x == x && p.y == y;\n}",
            difficulty: 3,
            riddle: "Two twins. Not the same identity.",
            conceptExplanation: "== checks reference, not logical equality.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 14",
            description: "Why does inserting a new object with same content overwrite the old key?",
            initialCode: "class Key {\n    int id;\n    Key(int id) { this.id = id; }\n}\n\nMap<Key,String> map = new HashMap<>();\nmap.put(new Key(1), \"A\");\nmap.put(new Key(1), \"B\");\nSystem.out.println(map.size());",
            correctCode: "@Override\npublic int hashCode() {\n    return Integer.hashCode(id);\n}",
            difficulty: 3,
            riddle: "Looks identical. Bucket decides.",
            conceptExplanation: "HashMap uses hashCode() and equals(); missing hashCode causes collisions.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 15",
            description: "Why does calling super() give an error?",
            initialCode: "class Parent {\n    Parent(int x) {}\n}\n\nclass Child extends Parent {\n    Child() {\n        super();\n    }\n}",
            correctCode: "Child() {\n    super(10);\n}",
            difficulty: 3,
            riddle: "The parent expects input. Child gave none.",
            conceptExplanation: "Parent has no no-arg constructor; must pass arguments.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 16",
            description: "Why does filtering a stream give no results?",
            initialCode: "List<String> names = List.of(\"Alice\", \"Bob\");\nnames.stream()\n     .filter(n -> { n.toUpperCase(); return true; })\n     .forEach(System.out::println);",
            correctCode: ".filter(n -> n.toUpperCase().equals(\"ALICE\"))",
            difficulty: 3,
            riddle: "You changed a copy. Original remains.",
            conceptExplanation: "Strings are immutable; toUpperCase() returns a new string.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 17",
            description: "Why does this method call fail to compile?",
            initialCode: "class Test {\n    void process(int x, long y) {}\n    void process(long x, int y) {}\n}\n\nTest t = new Test();\nt.process(5,5);",
            correctCode: "t.process(5, 5L);",
            difficulty: 3,
            riddle: "Same numbers. Ambiguous path.",
            conceptExplanation: "Compiler cannot disambiguate exact overload with literals.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 18",
            description: "Why does this throw an uncaught exception?",
            initialCode: "try {\n    throw new IOException();\n} catch (Exception e) {\n    System.out.println(\"Caught\");\n}",
            correctCode: "catch (IOException e) { System.out.println(\"Caught\"); }",
            difficulty: 3,
            riddle: "Parent trap missed child.",
            conceptExplanation: "IOException must be caught or declared; compiler forces checked exceptions to match.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 19",
            description: "Why do modifications to one object affect the other?",
            initialCode: "class Container {\n    List<String> items;\n    Container(List<String> items) { this.items = items; }\n}\n\nList<String> list = new ArrayList<>();\nContainer c1 = new Container(list);\nContainer c2 = new Container(list);\n\nc1.items.add(\"X\");\nSystem.out.println(c2.items.size());",
            correctCode: "this.items = new ArrayList<>(items);",
            difficulty: 3,
            riddle: "Shared blood. Separate bodies expected.",
            conceptExplanation: "Both objects reference same list; need defensive copy.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 20",
            description: "Why does calling defaultMethod() fail?",
            initialCode: "interface A {\n    default void show() {}\n}\n\nclass B implements A {\n    void show() {}\n}\n\nA obj = new B();\nobj.defaultMethod();",
            correctCode: "obj.show();",
            difficulty: 3,
            riddle: "You changed the shape. The label remained.",
            conceptExplanation: "Method name must match; no defaultMethod() exists in interface.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 21",
            description: "Why does this class fail to compile?",
            initialCode: "interface A { void show(); }\ninterface B { void show(); }\n\nclass C implements A, B {\n}",
            correctCode: "class C implements A, B {\n    public void show() {}\n}",
            difficulty: 3,
            riddle: "Two parents. One child. Must speak once.",
            conceptExplanation: "Implementing multiple interfaces with same method requires one concrete implementation.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 22",
            description: "Why does the inner class not see x?",
            initialCode: "class Outer {\n    int x = 10;\n\n    class Inner {\n        void print() {\n            int x = 20;\n            System.out.println(x + Outer.this.y);\n        }\n    }\n}",
            correctCode: "System.out.println(x + Outer.this.x);",
            difficulty: 3,
            riddle: "Two x's. One belongs outside.",
            conceptExplanation: "Inner class can reference outer class via Outer.this; wrong variable used.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 23",
            description: "Why does this fail at runtime?",
            initialCode: "List raw = new ArrayList<String>();\nraw.add(10);\n\nString s = (String) raw.get(0);",
            correctCode: "List<String> list = new ArrayList<>();\nlist.add(\"Hello\");",
            difficulty: 3,
            riddle: "The container says String. Reality disagrees.",
            conceptExplanation: "Raw types bypass compile-time checks; unsafe cast causes ClassCastException.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 24",
            description: "Why does getDeclaredField fail?",
            initialCode: "class Test { private int x; }\n\nField f = Test.class.getField(\"x\");",
            correctCode: "Field f = Test.class.getDeclaredField(\"x\");\nf.setAccessible(true);",
            difficulty: 3,
            riddle: "Hidden treasure. Wrong map.",
            conceptExplanation: "Private fields require getDeclaredField() and setAccessible(true).",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 25",
            description: "Why does output vary between runs?",
            initialCode: "class Printer extends Thread {\n    int id;\n    Printer(int id) { this.id = id; }\n\n    public void run() {\n        System.out.println(\"Printing \" + id);\n    }\n}\n\nnew Printer(1).start();\nnew Printer(2).start();",
            correctCode: "Use synchronization if order matters:\n\nsynchronized(System.out) { System.out.println(...); }",
            difficulty: 3,
            riddle: "Two hands. One clock. Chaos.",
            conceptExplanation: "Thread scheduling is nondeterministic; no guaranteed order.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 26",
            description: "Why does the lambda see the wrong variable?",
            initialCode: "int x = 5;\nRunnable r = new Runnable() {\n    int x = 10;\n    public void run() { System.out.println(x); }\n};\nr.run();",
            correctCode: "final int x = 5;\nRunnable r = () -> System.out.println(x);",
            difficulty: 3,
            riddle: "Outer x waits. Inner x speaks.",
            conceptExplanation: "Anonymous classes can have their own fields that shadow outer variables.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 27",
            description: "Why does increment still fail?",
            initialCode: "volatile int count = 0;\n\ncount++;",
            correctCode: "AtomicInteger count = new AtomicInteger(0);\ncount.incrementAndGet();",
            difficulty: 3,
            riddle: "Visible, but not atomic.",
            conceptExplanation: "volatile ensures visibility, but doesn't make compound operations atomic.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 28",
            description: "Why can't a static nested class use y?",
            initialCode: "class Outer {\n    int y = 10;\n\n    static class Inner {\n        void print() {\n            System.out.println(y);\n        }\n    }\n}",
            correctCode: "Outer o = new Outer();\nSystem.out.println(o.y);",
            difficulty: 3,
            riddle: "Detached branch. Needs trunk.",
            conceptExplanation: "Static nested classes cannot access non-static members directly.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 29",
            description: "Why can't the compiler infer type?",
            initialCode: "class Util {\n    static <T> void printList(List<T> list) {}\n}\n\nList<Integer> nums = List.of(1,2,3);\nUtil.<String>printList(nums);",
            correctCode: "Util.printList(nums);",
            difficulty: 3,
            riddle: "Type claimed. Reality differs.",
            conceptExplanation: "Explicit type argument conflicts with actual type; compiler cannot reconcile.",
            language: .java
        ))
        questions.append(Question(
            title: "Level 3 – Question 30",
            description: "Why do threads hang forever?",
            initialCode: "class Deadlock {\n    Object lock1 = new Object();\n    Object lock2 = new Object();\n\n    void t1() { synchronized(lock1){ synchronized(lock2){} } }\n    void t2() { synchronized(lock2){ synchronized(lock1){} } }\n}",
            correctCode: "Acquire locks in consistent order.",
            difficulty: 3,
            riddle: "Two hands grab two sticks in reverse. Freeze.",
            conceptExplanation: "Deadlock occurs when threads acquire locks in conflicting orders.",
            language: .java
        ))

        return questions
    }
